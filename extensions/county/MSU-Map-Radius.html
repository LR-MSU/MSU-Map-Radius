<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michigan Counties Map</title>
    <style>
        .circle {
            fill: #e6e6e6;
            stroke: #e6e6e6;
            stroke-width: 0.5;
            opacity: 1;
            pointer-events: none;
        }

        .dot, .center-dot {
            stroke: #898989;
            stroke-width: 0.5;
            r: 3;
        }

        .center-dot {
            opacity: 0.75;
        }

        .prior-same, .current-same {
            fill: #59c18f;
        }

        .prior-closed {
            fill: #ffffff;
        }

        .current-new {
            fill: #684183;
        }

        .county {
            fill-opacity: 0;
            stroke: #000000;
            stroke-width: 1px;
            transition: stroke 0.3s, stroke-width 0.3s;
        }

        body {
            overflow-y: hidden; /* Hide vertical scrollbar */
            overflow-x: hidden; /* Hide horizontal scrollbar */
        }

        .state {
            fill: none;
            stroke: #000000;
            stroke-width: 1px;
        }

        .tooltip {
            position: absolute;
            background-color: white;
            border: 1px solid #ddd;
            padding: 10px;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            opacity: 0;
        }

        .tooltip-category {
            color: #888;
            font-weight: bold;
        }

        .tooltip-value {
            color: #333;
            font-weight: bold;
        }

        #loading {
            position: fixed;
            width: 100vw;
            height: 100vh;
            background: white;
            z-index: 1000;
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .spinner {
            animation: spin 1s linear infinite;
        }

        /* Context Menu Styles */
        #contextMenu {
            position: fixed;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 8px;
            display: none;
            z-index: 1000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            min-width: 220px;
            font-size: 12px;
        }

        .menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            cursor: move;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 6px;
        }

        .menu-header h2 {
            margin: 0;
            font-size: 13px;
            color: #333333;
            font-weight: 600;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #666666;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .close-button:hover {
            color: #333333;
            background-color: #f0f0f0;
        }

        .menu-section {
            margin-bottom: 12px;
            padding: 8px 12px;
            border-radius: 4px;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .menu-section h3 {
            margin: 0 0 8px 0;
            font-size: 11px;
            color: #666666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e0e0e0;
        }

        .menu-section .menu-item {
            margin-bottom: 8px;
        }

        .menu-section .menu-item:last-child {
            margin-bottom: 0;
        }

        .menu-section .menu-item label {
            display: block;
            font-size: 11px;
            color: #666666;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .menu-section .menu-item input[type="color"] {
            width: 100%;
            height: 24px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 2px;
        }

        .menu-section .menu-item input[type="range"] {
            width: 100%;
            margin: 4px 0;
            -webkit-appearance: none;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            outline: none;
        }

        .menu-section .menu-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #2c5282;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .menu-section .menu-item input[type="number"] {
            width: 80px;
            height: 24px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 0 6px;
            font-size: 12px;
            margin-right: 4px;
        }

        .menu-section .menu-item .unit {
            font-size: 11px;
            color: #666666;
        }

        .confirm-button {
            width: 100%;
            padding: 6px;
            background: #2c5282;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 8px;
            font-size: 12px;
            font-weight: 500;
        }

        .confirm-button:hover {
            background: #2b6cb0;
        }

        .button-group {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .save-button, .load-button {
            flex: 1;
            padding: 6px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            background: #ffffff;
        }

        .save-button {
            color: #2c5282;
            border-color: #2c5282;
        }

        .save-button:hover {
            background: #ebf8ff;
        }

        .load-button {
            color: #666666;
        }

        .load-button:hover {
            background: #f5f5f5;
        }

        .view-button {
            width: 100%;
            padding: 6px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            background: #ffffff;
            color: #666666;
            margin-top: 6px;
        }

        .view-button:hover {
            background: #f5f5f5;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffffff;
            padding: 16px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            min-width: 300px;
            max-width: 400px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 14px;
            color: #333333;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666666;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .modal-close:hover {
            color: #333333;
            background-color: #f0f0f0;
        }

        .settings-list {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            font-size: 12px;
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-label {
            font-weight: 500;
            color: #666666;
        }

        .settings-value {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #333333;
        }

        .color-preview {
            width: 16px;
            height: 16px;
            border: 1px solid #e0e0e0;
            border-radius: 2px;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="../../assets/tableau.extensions.1.latest.js"></script>
</head>
<body>
<div id="loading">
    <img src="../../assets/loading.png" class="spinner" alt="Loading..."/>
</div>
<svg width="100vw" height="100vh">
    <defs>
        <clipPath id="stateClip">
            <path id="state-border"></path>
        </clipPath>
    </defs>
    <g id="mapGroup" clip-path="url(#stateClip)">
        <g id="circlesLayer"></g>
        <g id="bordersLayer"></g>
        <g id="dotsLayer"></g>
    </g>
</svg>
<div id="tooltip" class="tooltip"></div>
<div id="contextMenu">
    <div class="menu-header">
        <h2>Map Settings</h2>
        <button class="close-button">&times;</button>
    </div>

    <div class="menu-section">
        <h3>Circles</h3>
        <div class="menu-item">
            <label>Color</label>
            <input type="color" class="color-picker" id="circleColor" value="#e6e6e6">
        </div>
        <div class="menu-item">
            <label>Range from Center</label>
            <input type="number" class="radius-input" id="radiusInput" min="1" max="100" value="20" step="1">
            <span class="unit">miles</span>
        </div>
    </div>

    <div class="menu-section">
        <h3>Dots</h3>
        <div class="menu-item">
            <label>Size</label>
            <input type="range" class="size-slider" id="dotSize" min="1" max="10" value="3">
        </div>
        <div class="menu-item">
            <label>Prior Year Only</label>
            <input type="color" class="color-picker" id="priorClosedDotColor" value="#ffffff">
        </div>
        <div class="menu-item">
            <label>Both Years</label>
            <input type="color" class="color-picker" id="priorSameDotColor" value="#59c18f">
        </div>
        <div class="menu-item">
            <label>New This Year</label>
            <input type="color" class="color-picker" id="currentNewDotColor" value="#684183">
        </div>
    </div>

    <button class="confirm-button" id="confirmStyles">Confirm Changes</button>
    <div class="button-group">
        <button class="save-button" id="saveSettings">Save Settings</button>
        <button class="load-button" id="loadSettings">Load Settings</button>
    </div>
    <button class="view-button" id="viewSettings">View Saved Settings</button>
</div>
<div id="settingsModal" class="modal">
    <div class="modal-header">
        <h2>Saved Settings</h2>
        <button class="modal-close">&times;</button>
    </div>
    <ul class="settings-list">
        <li class="settings-item">
            <span class="settings-label">Circle Color</span>
            <span class="settings-value">
                <div class="color-preview" id="savedCircleColor"></div>
                <span id="savedCircleColorValue"></span>
            </span>
        </li>
        <li class="settings-item">
            <span class="settings-label">Circle Radius</span>
            <span class="settings-value" id="savedRadiusInMiles"></span>
        </li>
        <li class="settings-item">
            <span class="settings-label">Prior Year Only</span>
            <span class="settings-value">
                <div class="color-preview" id="savedPriorClosedDotColor"></div>
                <span id="savedPriorClosedDotColorValue"></span>
            </span>
        </li>
        <li class="settings-item">
            <span class="settings-label">Both Years</span>
            <span class="settings-value">
                <div class="color-preview" id="savedPriorSameDotColor"></div>
                <span id="savedPriorSameDotColorValue"></span>
            </span>
        </li>
        <li class="settings-item">
            <span class="settings-label">New This Year</span>
            <span class="settings-value">
                <div class="color-preview" id="savedCurrentNewDotColor"></div>
                <span id="savedCurrentNewDotColorValue"></span>
            </span>
        </li>
        <li class="settings-item">
            <span class="settings-label">Dot Size</span>
            <span class="settings-value" id="savedDotSize"></span>
        </li>
    </ul>
</div>
<script>
    // Show the loading spinner when the map starts loading
    function showLoading() {
        d3.select("#loading").style("display", "flex");
    }

    // Hide the loading spinner when the map has finished loading
    function hideLoading() {
        d3.select("#loading").style("display", "none");
    }

    const svgConst = document.querySelector('svg');

    // Get the bounding rectangle of the SVG
    const svgRect = svgConst.getBoundingClientRect();

    // Set the width and height constants
    const width = svgRect.width;
    const height = svgRect.height;

    /**
     * SVG element for the map visualization.
     * @type {void | Intl.LDMLPluralRule}
     */
    const svg = d3.select("svg");

    /**
     * Group element containing the map's components.
     * @type {void | Intl.LDMLPluralRule}
     */
    const mapGroup = svg.select("#mapGroup");

    /**
     * Tooltip element for displaying information on hover.
     * @type {void | Intl.LDMLPluralRule}
     */
    const tooltip = d3.select("#tooltip");

    /**
     * Mercator type projection for the map
     * @type {*|void}
     */
    const projection = d3.geoMercator()
        .scale(4000)
        .center([-84.506, 44.182])
        .translate([width / 2, height / 2]);

    /**
     * Path generator for creating SVG paths from GeoJSON data.
     */
    const path = d3.geoPath().projection(projection);

    /**
     * Defines zoom behavior for the map.
     */
    const zoom = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", zoomed);

    // Takes a page of data, which has a list of DataValues (dataTablePage.data)
    // and a list of columns and puts the data in a list where each entry is an
    // object that maps from field names to DataValues
    // (example of a row being: { SUM(Sales): ..., SUM(Profit): ..., Ship Mode: ..., })
    function convertToListOfNamedRows(dataTablePage) {
        console.time('convertToListOfNamedRows');

        const {columns, data} = dataTablePage;
        const columnMap = columns.map(col => col.fieldName);

        const rows = data.map(row =>
            Object.fromEntries(columnMap.map((key, index) => [key, row[columns[index].index]]))
        );

        console.timeEnd('convertToListOfNamedRows');
        return rows;
    }


    // Uses getVisualSpecificationAsync to build a map of encoding identifiers (specified in the .trex file)
    // to fields that the user has placed on the encoding's shelf.
    // Only encodings that have fields dropped on them will be part of the encodingMap.
    async function getEncodingMap(worksheet) {
        const visualSpec = await worksheet.getVisualSpecificationAsync();

        const encodingMap = {};

        if (visualSpec.activeMarksSpecificationIndex < 0) return encodingMap;

        const marksCard =
            visualSpec.marksSpecifications[visualSpec.activeMarksSpecificationIndex];
        console.time('175-177')
        for (const encoding of marksCard.encodings) {
            encodingMap[encoding.id] = encoding.field;
        }
        console.timeEnd('175-177')
        return encodingMap;
    }

    // Gets each page of data in the summary data and returns a list of rows of data
    // associated with field names.
    async function getSummaryDataTable(worksheet) {
        console.time('getSummaryDataTable');

        // Fetch the summary data using the DataTableReader
        const dataTableReader = await worksheet.getSummaryDataReaderAsync(undefined, {ignoreSelection: true});

        const rows = [];
        const pagePromises = [];

        for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {
            pagePromises.push(dataTableReader.getPageAsync(currentPage));
        }

        const pages = await Promise.all(pagePromises);

        for (const dataTablePage of pages) {
            rows.push(...convertToListOfNamedRows(dataTablePage));
        }

        await dataTableReader.releaseAsync();

        console.timeEnd('getSummaryDataTable');
        return rows;
    }


    // Initializes the map
    function initializeMap() {
        /**
         * Applies zoom behavior to the SVG element
         */
        svg.call(zoom);

        /**
         * Function to handle zoom events.
         * @param event - The zoom event object.
         */
        d3.select("body").on("keydown", function (event) {
            if (event.key === "Escape") {
                reset();
            }
        });
    }

    // Load and process data
    function loadData() {
        //showLoading();
        /**
         * Load and process the JSON file containing geographical data.
         * This asynchronous function fetches the 'michiganCountyGeo.json' file, containing
         * TopoJSON data for Michigan counties and state boundaries.
         */

        d3.json("../../assets/michiganCountyGeo.json").then(data => {

            /**
             * GeoJSON features representing Michigan counties.
             */
            const michiganCounties = topojson.feature(data, data.objects.cb_2015_us_county_20m)
                .features.filter(d => d.properties.STATEFP === "26");

            /**
             * GeoJSON feature representing the state of Michigan as a whole.
             */
            const michiganState = topojson.feature(data, data.objects.cb_2018_us_state_20m)
                .features.find(d => d.properties.STATEFP === "26");

            renderMap(michiganCounties, michiganState);

            // Leads to lat longs and the param nonsense
            processCircleData(michiganState);
        });
    }

    /**
     * Calls functions that render the map
     */
    function renderMap(michiganCounties, michiganState) {
        renderCounties(michiganCounties);
        renderStateBorder(michiganState);
    }

    /**
     * Renders county borders
     */
    function renderCounties(michiganCounties) {
        console.log("Rendering counties...");
        console.time("renderCounties");

        // Efficiently update counties using d3.join()
        const bordersLayer = d3.select("#bordersLayer");

        bordersLayer.selectAll(".county")
            .data(michiganCounties, d => d.properties.GEOID) // Use GEOID as unique key
            .join(
                enter => enter.append("path")
                    .attr("class", "county")
                    .attr("d", path)
                    .attr("id", d => `county-${d.properties.GEOID}`)
                    .on("click", clickedCounty)
                    .on("mouseover", (event, d) => requestAnimationFrame(() => showTooltip(event, d)))
                    .on("mousemove", (event, d) => requestAnimationFrame(() => showTooltip(event, d)))
                    .on("mouseout", hideTooltip),
                update => update.attr("d", path),
                exit => exit.remove()
            );

        console.timeEnd("renderCounties");
    }

    /**
     * Selects and updates the existing state border element.
     */
    function renderStateBorder(michiganState) {
        console.log("Entered renderStateBorder")
        svg.select("#state-border")
            .datum(michiganState)
            .attr("d", path);

        d3.select("#bordersLayer")
            .append("path")
            .datum(michiganState)
            .attr("class", "state")
            .attr("d", path)
            .attr("id", `state-${michiganState.properties.GEOID}`);
    }

    /**
     * Reloads and rerenders map nad calculations
     */
    async function refreshData(circleGeoJSONs, radiusInKm, michiganState, worksheet) {
        try {
            console.log("Entered refreshData");
            console.time("refreshData");

            // Fetch summary data and encoding map in parallel
            const [summaryData, encodingMap] = await Promise.all([
                getSummaryDataTable(worksheet),
                getEncodingMap(worksheet)
            ]);

            const { detail, x, y, x2, y2 } = encodingMap;
            const detailName = detail.name;
            const longitudeName = x.name;
            const latitudeName = y.name;
            const longitude2Name = x2.name;
            const latitude2Name = y2.name;

            // Initialize arrays and sets
            const validDotCoordinates = [];
            const validCircleCoordinates = [];
            const priorIds = new Set();
            const newIds = new Set();

            // Process each row once
            for (const row of summaryData) {
                const id = row[detailName]?._value;

                // Process dot coordinates
                const lat = row[latitudeName]?._value;
                const lon = row[longitudeName]?._value;
                if (isValidCoordinate(lat, lon)) {
                    validDotCoordinates.push({ lat, lon, id });
                    newIds.add(id);
                }

                // Process circle coordinates
                const lat2 = row[latitude2Name]?._value;
                const lon2 = row[longitude2Name]?._value;
                if (isValidCoordinate(lat2, lon2)) {
                    validCircleCoordinates.push({ lat2, lon2, id });
                    priorIds.add(id);
                }
            }

            function isValidCoordinate(lat, lon) {
                return (
                    isFinite(lat) &&
                    isFinite(lon) &&
                    lat >= -90 &&
                    lat <= 90 &&
                    lon >= -180 &&
                    lon <= 180
                );
            }

            // Add existedInPrior and closedInNew properties
            validDotCoordinates.forEach(item => {
                item.existedInPrior = priorIds.has(item.id);
            });
            validCircleCoordinates.forEach(item => {
                item.closedInNew = !newIds.has(item.id);
            });

            // Create unique coordinates using efficient deduplication
            const uniqueDotCoordinates = deduplicate(validDotCoordinates, 'lat', 'lon');
            const uniqueCircleCoordinates = deduplicate(
                validCircleCoordinates.filter(item => item.closedInNew),
                'lat2',
                'lon2'
            );

            console.timeEnd("refreshData");
            console.time("All scripts supposedly");

            renderCircles(uniqueCircleCoordinates, uniqueDotCoordinates, radiusInKm);

            const dotGeoJSONs = uniqueDotCoordinates.map(({ lat, lon }) =>
                createCircleGeoJSON(lat, lon, radiusInKm)
            );

            calculateAreas(dotGeoJSONs, michiganState);

            // Helper function for deduplication
            function deduplicate(arr, latKey, lonKey) {
                const map = new Map();
                for (const item of arr) {
                    const key = `${item[latKey]},${item[lonKey]}`;
                    if (!map.has(key)) map.set(key, item);
                }
                return Array.from(map.values());
            }

            console.timeEnd("All scripts supposedly");
        } catch (error) {
            console.error("Error in refreshData:", error);
        }
    }

    /**
     * Processes Circle data
     */
    function processCircleData(michiganState) {
        /**
         * Array of dictionaries with circle coordinates
         */
        let circleCoordinates = [
            {lat: 0, lon: 0}
        ];

        // Use saved radius or default to 20 miles
        const radiusInMiles = customizationState.radiusInMiles;
        const radiusInKm = radiusInMiles * 1.60934;
        const circleGeoJSONs = circleCoordinates.map(circle => createCircleGeoJSON(circle.lat, circle.lon, radiusInKm));

        // Leads to params
        console.log("Leading to params")

        let worksheet = tableau.extensions.worksheetContent.worksheet;
        refreshData(
            circleGeoJSONs,
            radiusInKm,
            michiganState,
            worksheet
        )
    }

    /**
     * Calculates the total covered area of the circles
     */
    function calculateAreas(dotGeoJSONs, michiganState) {
        console.log("Entered calculateAreas");
        console.time("calculateAreas");

        if (!dotGeoJSONs || dotGeoJSONs.length === 0) {
            console.warn("No circles to process.");
            return;
        }

        const worker = new Worker('../../assets/Worker.js');
        worker.postMessage({dotGeoJSONs, michiganBoundary: michiganState});

        worker.onmessage = function (e) {
            if (e.data.type === 'results') {
                console.timeEnd("calculateAreas");
                console.log("Worker finished processing");

                const {
                    totalCircleArea,
                    totalIntersectionAreaBeforeUnioning,
                    areaOutsideMap,
                    finalNonOverlappingArea
                } = e.data.results;

                console.log(`Total Circle Area: ${totalCircleArea} km²`);
                console.log(`Overlap Area: ${totalIntersectionAreaBeforeUnioning} km²`);
                console.log(`Area Outside Map: ${areaOutsideMap} km²`);
                console.log(`Final Non-Overlapping Area: ${finalNonOverlappingArea} km²`);

                updateTableauParameters(
                    totalCircleArea,
                    totalIntersectionAreaBeforeUnioning,
                    areaOutsideMap,
                    finalNonOverlappingArea
                );
            } else if (e.data.type === 'log') {
                console.log(e.data.message);
            }
        };

        worker.onerror = function (e) {
            console.error("Worker error:", e.message);
        };
    }

    /**
     * Renders the circle
     */
    function renderCircles(circleCoordinates, dotCoordinates, radiusInKm) {
        console.log("Entered render circles")
        console.time('446-453 Send data and recieve back data from worker')
        console.time('447- 498 Start to termination of circle worker')

        // Store current coordinates for re-rendering
        window.currentCircleCoordinates = circleCoordinates;
        window.currentDotCoordinates = dotCoordinates;
        window.currentRadiusInKm = radiusInKm;

        console.timeEnd('446-453 Send data and recieve back data from worker')
        console.time('Worker visual response')
        const dotsLayer = d3.select("#dotsLayer");
        const circlesLayer = d3.select("#circlesLayer");

        // Precompute projected coordinates and paths
        dotCoordinates = dotCoordinates.map(d => {
            const projected = projection([d.lon, d.lat]);
            return {
                ...d,
                projected,
                path: circlePath(d.lat, d.lon, radiusInKm, projection),
            };
        });

        circleCoordinates = circleCoordinates.map(d => {
            const projectedCenter = projection([d.lon2, d.lat2]);
            return {
                ...d,
                projectedCenter,
            };
        });

        // Filter and sort data for correct z-order
        const priorSame = circleCoordinates.filter(d => !d.closedInNew);
        const priorClosed = circleCoordinates.filter(d => d.closedInNew);
        const currentSame = dotCoordinates.filter(d => d.existedInPrior);
        const currentNew = dotCoordinates.filter(d => !d.existedInPrior);

        // 1. Draw background circles (non-closed current sites)
        circlesLayer.selectAll(".circle")
            .data([...currentSame, ...currentNew].filter(d => !d.closedInNew))
            .join("path")
            .attr("class", "circle")
            .attr("d", d => d.path)
            .style("fill", customizationState.circleColor)
            .style("stroke", customizationState.circleColor);

        // 2. Prior same sites (lowest)
        circlesLayer.selectAll(".center-dot.prior-same")
            .data(priorSame, d => d.id)
            .join("circle")
            .attr("class", "center-dot prior-same")
            .attr("cx", d => d.projectedCenter[0])
            .attr("cy", d => d.projectedCenter[1])
            .style("fill", customizationState.priorSameDotColor)
            .style("r", customizationState.dotSize);

        // 3. Current same sites
        dotsLayer.selectAll(".dot.current-same")
            .data(currentSame, d => d.id)
            .join("circle")
            .attr("class", "dot current-same")
            .attr("cx", d => d.projected[0])
            .attr("cy", d => d.projected[1])
            .style("fill", customizationState.priorSameDotColor)
            .style("r", customizationState.dotSize);

        // 4. Prior closed sites
        circlesLayer.selectAll(".center-dot.prior-closed")
            .data(priorClosed, d => d.id)
            .join("circle")
            .attr("class", "center-dot prior-closed")
            .attr("cx", d => d.projectedCenter[0])
            .attr("cy", d => d.projectedCenter[1])
            .style("fill", customizationState.priorClosedDotColor)
            .style("r", customizationState.dotSize);

        // 5. Current new sites (topmost)
        dotsLayer.selectAll(".dot.current-new")
            .data(currentNew, d => d.id)
            .join("circle")
            .attr("class", "dot current-new")
            .attr("cx", d => d.projected[0])
            .attr("cy", d => d.projected[1])
            .style("fill", customizationState.currentNewDotColor)
            .style("r", customizationState.dotSize);

        console.timeEnd('Worker visual response')
        hideLoading();
    }

    /**
     * Initializes extension and sets parameters to values from the calculations
     */
    function updateTableauParameters(totalCircleArea, totalIntersectionAreaBeforeUnioning, areaOutsideMap, finalNonOverlappingArea) {
        console.log("Entered updateTableauParameters")
        let worksheet = tableau.extensions.worksheetContent.worksheet;
        worksheet.getParametersAsync().then(parameters => {
            console.log(parameters)
            let totalAreaParameter = parameters.find(param => param.name === 'TotalArea');
            let overlapAreaParameter = parameters.find(param => param.name === 'OverlapArea');
            let outsideMapAreaParameter = parameters.find(param => param.name === 'OutsideMapArea');
            let finalAreaParameter = parameters.find(param => param.name === 'FinalArea');

            // console.log(totalAreaParameter, overlapAreaParameter, outsideMapAreaParameter, finalAreaParameter)

            /*console.log(
                parseFloat(totalCircleArea),
                parseFloat(totalIntersectionAreaBeforeUnioning),
                parseFloat(areaOutsideMap),
                parseFloat(finalNonOverlappingArea)
            )*/

            totalAreaParameter.changeValueAsync(parseFloat((totalCircleArea * 0.386102).toFixed(2)));
            overlapAreaParameter.changeValueAsync(parseFloat((totalIntersectionAreaBeforeUnioning * 0.386102).toFixed(2)));
            outsideMapAreaParameter.changeValueAsync(parseFloat((areaOutsideMap * 0.386102).toFixed(2)));
            finalAreaParameter.changeValueAsync(parseFloat((finalNonOverlappingArea * 0.386102).toFixed(2)));
        });
    }

    /**
     * Applies zoom behavior
     */
    function zoomed(event) {
        mapGroup.attr("transform", event.transform);
    }

    /**
     * Display tooltip with county information.
     * @param {Event} event - Mouse hover event.
     * @param {Object} d - Data object for the hovered county.
     */
    function showTooltip(event, d) {
        tooltip.transition()
            .duration(200)
            .style("opacity", 0.9);
        tooltip.html(`
                <span class="tooltip-category">County Name:</span> <span class="tooltip-value">${d.properties.NAME}</span><br/>
            `)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
        const tooltipNode = tooltip.node();

        /**
         * Bounding rectangle of the tooltip element.
         * @type {DOMRect}
         */
        const tooltipRect = tooltipNode.getBoundingClientRect();
        const svgRect = svg.node().getBoundingClientRect();
        if (tooltipRect.right > svgRect.right) {
            tooltip.style("left", (event.pageX - tooltipRect.width - 10) + "px");
        }
        if (tooltipRect.bottom > svgRect.bottom) {
            tooltip.style("top", (event.pageY - tooltipRect.height - 10) + "px");
        }
    }

    /**
     * Hide the tooltip.
     */
    function hideTooltip() {
        tooltip.transition()
            .duration(500)
            .style("opacity", 0);
    }

    /**
     * Generate a circular path based on latitude, longitude, and radius.
     * Sourced from; https://stackoverflow.com/questions/29734397/drawing-a-fixed-length-circle-in-d3-js
     * @param {number} lat - Latitude of the circle center.
     * @param {number} lon - Longitude of the circle center.
     * @param {number} radius - Radius of the circle in kilometers.
     * @param {Function} projection - Map projection function.
     * @returns {string|Array} - SVG path string or array of coordinates.
     */
    function circlePath(lat, lon, radius, projection) {
        var intervals = 72;
        var intervalAngle = (360 / intervals);
        var pointsData = [];
        for (var i = 0; i < intervals; i++) {
            pointsData.push(getDestinationPoint(lat, lon, i * intervalAngle, radius));
        }

        if (projection) {
            var pointsData2 = [];
            for (var i in pointsData) {
                pointsData2.push(projection([pointsData[i][1], pointsData[i][0]]));
            }
            return d3.line()(pointsData2) + "Z";
        } else {
            return pointsData;
        }
    }

    /**
     * Calculate destination point given start coordinates, bearing, and distance.
     * Sourced from; https://stackoverflow.com/questions/29734397/drawing-a-fixed-length-circle-in-d3-js
     * @param {number} lat - Starting latitude.
     * @param {number} lon - Starting longitude.
     * @param {number} brng - Bearing in degrees.
     * @param {number} d - Distance in kilometers.
     * @returns {number[]} - Destination coordinates [lat, lon].
     */
    function getDestinationPoint(lat, lon, brng, d) {
        var R = 6371; // Earth's radius in km
        var deg2rad = Math.PI / 180; // Conversion factor from degrees to radians
        var rad2deg = 180 / Math.PI; // Conversion factor from radians to degrees

        // Convert input angles from degrees to radians
        brng *= deg2rad; // Convert bearing to radians
        lat *= deg2rad; // Convert latitude to radians
        lon *= deg2rad; // Convert longitude to radians

        // Calculate the destination latitude using the haversine formula
        var lat2 = Math.asin(
            Math.sin(lat) * Math.cos(d / R) +
            Math.cos(lat) * Math.sin(d / R) * Math.cos(brng)
        );

        // Calculate the destination longitude using the haversine formula
        var lon2 = lon + Math.atan2(
            Math.sin(brng) * Math.sin(d / R) * Math.cos(lat),
            Math.cos(d / R) - Math.sin(lat) * Math.sin(lat2)
        );

        // Convert the calculated latitude and longitude back to degrees and return as an array
        return [lat2 * rad2deg, lon2 * rad2deg];
    }

    /**
     * Function to create Circle as GEO JSON
     */
    function createCircleGeoJSON(lat, lon, radius) {
        return turf.circle([lon, lat], radius, {steps: 64, units: 'kilometers'});
    }


    /**
     * Zoom behavior for county click, making sure no part is cut out
     */
    function clickedCounty(event, d) {
        const [[x0, y0], [x1, y1]] = path.bounds(d);
        event.stopPropagation();
        svg.transition().duration(750).call(
            zoom.transform,
            d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(Math.min(40, 0.5 / Math.max((x1 - x0) / width, (y1 - y0) / height)))
                .translate(-(x0 + x1) / 2, -(y0 + y1) / 2)
        );
    }

    /**
     * Resets map zoom
     */
    function reset() {
        svg.transition().duration(750).call(
            zoom.transform,
            d3.zoomIdentity,
            d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
        );
    }

    // Customization state
    let customizationState = {
        circleColor: "#e6e6e6",
        priorClosedDotColor: "#ffffff",  // White dots (existed last year, not this year)
        priorSameDotColor: "#59c18f",    // Green dots (existed in both years)
        currentNewDotColor: "#684183",   // Purple dots (new this year)
        dotSize: 3,
        radiusInMiles: 20
    };

    // Saved state - will track last saved settings
    let savedState = {
        circleColor: "#e6e6e6",
        priorClosedDotColor: "#ffffff",
        priorSameDotColor: "#59c18f",
        currentNewDotColor: "#684183",
        dotSize: 3,
        radiusInMiles: 20
    };

    // Context menu elements
    const contextMenu = d3.select("#contextMenu");
    const circleColorPicker = d3.select("#circleColor");
    const priorClosedDotColorPicker = d3.select("#priorClosedDotColor");
    const priorSameDotColorPicker = d3.select("#priorSameDotColor");
    const currentNewDotColorPicker = d3.select("#currentNewDotColor");
    const dotSizeSlider = d3.select("#dotSize");
    const radiusInput = d3.select("#radiusInput");
    const confirmButton = d3.select("#confirmStyles");
    const settingsIcon = d3.select("#settingsIcon");
    const closeButton = d3.select(".close-button");
    const menuHeader = d3.select(".menu-header");
    const saveButton = d3.select("#saveSettings");
    const loadButton = d3.select("#loadSettings");
    const viewButton = d3.select("#viewSettings");
    const settingsModal = d3.select("#settingsModal");
    const modalCloseButton = d3.select(".modal-close");

    // Function to save settings to Tableau workbook
    async function saveSettingsToTableau() {
        try {
            await tableau.extensions.settings.saveAsync();
            console.log("Settings saved successfully");
        } catch (error) {
            console.error("Error saving settings:", error);
        }
    }

    // Function to save current customization state
    async function saveSettings() {
        try {
            // Update savedState with current values
            Object.keys(customizationState).forEach(key => {
                savedState[key] = customizationState[key];
            });

            // Save each setting individually to Tableau
            Object.entries(savedState).forEach(([key, value]) => {
                tableau.extensions.settings.set(key, value.toString());
            });

            // Save to workbook
            await saveSettingsToTableau();
        } catch (error) {
            console.error("Error saving settings:", error);
        }
    }

    // Function to load saved settings
    function loadSettings() {
        try {
            // First load from Tableau settings into savedState if they exist
            Object.keys(savedState).forEach(key => {
                const tableauValue = tableau.extensions.settings.get(key);
                if (tableauValue) {
                    savedState[key] = key.includes('Size') ? parseInt(tableauValue) : tableauValue;
                }
            });

            // Then update customizationState from savedState
            Object.keys(customizationState).forEach(key => {
                customizationState[key] = savedState[key];
            });

            // Update UI elements
            circleColorPicker.property('value', customizationState.circleColor);
            priorClosedDotColorPicker.property('value', customizationState.priorClosedDotColor);
            priorSameDotColorPicker.property('value', customizationState.priorSameDotColor);
            currentNewDotColorPicker.property('value', customizationState.currentNewDotColor);
            dotSizeSlider.property('value', customizationState.dotSize);
            radiusInput.property('value', customizationState.radiusInMiles);

            // Re-render with loaded settings
            if (window.currentCircleCoordinates && window.currentDotCoordinates && window.currentRadiusInKm) {
                renderCircles(window.currentCircleCoordinates, window.currentDotCoordinates, window.currentRadiusInKm);
            }
        } catch (error) {
            console.error("Error loading settings:", error);
        }
    }

    // Add event listeners for save and load buttons
    saveButton.on("click", saveSettings);
    loadButton.on("click", loadSettings);

    // Make context menu draggable
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    menuHeader.on("mousedown", function(event) {
        isDragging = true;
        const menuRect = contextMenu.node().getBoundingClientRect();
        dragOffset.x = event.clientX - menuRect.left;
        dragOffset.y = event.clientY - menuRect.top;
        event.preventDefault(); // Prevent text selection during drag
    });

    d3.select("body").on("mousemove", function(event) {
        if (isDragging) {
            contextMenu
                .style("left", (event.clientX - dragOffset.x) + "px")
                .style("top", (event.clientY - dragOffset.y) + "px");
        }
    });

    d3.select("body").on("mouseup", function() {
        isDragging = false;
    });

    // Close context menu when close button is clicked
    closeButton.on("click", function() {
        contextMenu.style("display", "none");
    });

    // Close context menu when clicking outside
    d3.select("body").on("click", function(event) {
        const target = event.target;
        const isContextMenu = contextMenu.node().contains(target);

        if (!isContextMenu) {
            contextMenu.style("display", "none");
        }
    });

    // Remove right-click event listener from the map
    svg.on("contextmenu", null);

    // Update customization state when controls change
    circleColorPicker.on("change", function() {
        customizationState.circleColor = this.value;
    });

    priorClosedDotColorPicker.on("change", function() {
        customizationState.priorClosedDotColor = this.value;
    });

    priorSameDotColorPicker.on("change", function() {
        customizationState.priorSameDotColor = this.value;
    });

    currentNewDotColorPicker.on("change", function() {
        customizationState.currentNewDotColor = this.value;
    });

    dotSizeSlider.on("input", function() {
        customizationState.dotSize = this.value;
    });

    radiusInput.on("input", function() {
        customizationState.radiusInMiles = this.value;
    });

    // Apply changes when confirm button is clicked
    confirmButton.on("click", function() {
        // Convert miles to kilometers for calculations
        const radiusInKm = customizationState.radiusInMiles * 1.60934;

        // Apply style changes and recalculate areas
        if (window.currentCircleCoordinates && window.currentDotCoordinates) {
            renderCircles(window.currentCircleCoordinates, window.currentDotCoordinates, radiusInKm);

            // Recalculate areas with new radius
            const dotGeoJSONs = window.currentDotCoordinates.map(({ lat, lon }) =>
                createCircleGeoJSON(lat, lon, radiusInKm)
            );

            // Get the state boundary from the current data
            const michiganState = d3.select("#state-border").datum();
            calculateAreas(dotGeoJSONs, michiganState);
        }
    });

    // Function to update the settings modal with current saved values
    function updateSettingsModal() {
        try {
            // Update each setting display using savedState
            Object.keys(savedState).forEach(key => {
                const savedValue = savedState[key];
                if (key.includes('Color')) {
                    // Update color preview and value
                    d3.select(`#saved${key.charAt(0).toUpperCase() + key.slice(1)}`)
                        .style('background-color', savedValue);
                    d3.select(`#saved${key.charAt(0).toUpperCase() + key.slice(1)}Value`)
                        .text(savedValue);
                } else {
                    // Update other values (dotSize, radiusInMiles)
                    d3.select(`#saved${key.charAt(0).toUpperCase() + key.slice(1)}`)
                        .text(savedValue);
                }
            });
        } catch (error) {
            console.error("Error updating settings modal:", error);
        }
    }

    // Show settings modal
    viewButton.on("click", function() {
        updateSettingsModal();
        settingsModal.style("display", "block");
    });

    // Close settings modal
    modalCloseButton.on("click", function() {
        settingsModal.style("display", "none");
    });

    // Close modal when clicking outside
    d3.select("body").on("click", function(event) {
        const target = event.target;
        const isModal = settingsModal.node().contains(target);
        const isViewButton = viewButton.node().contains(target);

        if (!isModal && !isViewButton && settingsModal.style("display") !== "none") {
            settingsModal.style("display", "none");
        }
    });

    /**
     * Checks if there are any saved settings in Tableau
     * @returns {boolean} - True if any settings are saved, false otherwise
     */
    function hasSavedSettings() {
        return Object.keys(savedState).some(key =>
            tableau.extensions.settings.get(key) !== undefined
        );
    }

    /**
     * Initializes the map
     */
    function Start() {
        initializeMap();
        loadData();
        showLoading();

        // Check for and load saved settings after a brief delay to ensure initial rendering is complete
        setTimeout(() => {
            if (hasSavedSettings()) {
                console.log("Found saved settings, applying automatically...");
                // Load from Tableau to savedState first
                Object.keys(savedState).forEach(key => {
                    const tableauValue = tableau.extensions.settings.get(key);
                    if (tableauValue) {
                        savedState[key] = key.includes('Size') ? parseInt(tableauValue) : tableauValue;
                    }
                });
                loadSettings();
            }
        }, 1000); // 1 second delay to ensure initial rendering is complete
    }

    // Initialize and load data
    (function () {
        window.onload = tableau.extensions.initializeAsync({'configure': showSettingsMenu}).then(async () => {
            let worksheet = tableau.extensions.worksheetContent.worksheet
            worksheet.addEventListener(
                tableau.TableauEventType.SummaryDataChanged,
                Start
            );

            Start();
        }).catch((error) => {
            console.log(error.stack || error)
        });
    })();

    // Function to display the settings menu when Configure is clicked from the context menu
    function showSettingsMenu() {
        // Center the menu on the screen
        const menuWidth = 220; // Minimum width from CSS
        const menuHeight = 350; // Approximate height based on content

        contextMenu
            .style("left", (window.innerWidth / 2 - menuWidth / 2) + "px")
            .style("top", (window.innerHeight / 2 - menuHeight / 2) + "px")
            .style("display", "block");
    }
</script>
</body>
</html>
